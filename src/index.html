<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hexor Utility</title>
  <style>
    .titlebar {
      height: 28px;
      width: 100%;
      -webkit-app-region: drag;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 999;
      background: rgba(255, 0, 0, 0);
    }

    html,
    body {
      margin: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      font-weight: normal;
      color: #000;
      background-color: #fff;
      overflow: hidden;
    }

    body {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type=number] {
      appearance: textfield;
      -moz-appearance: textfield;
    }

    .color-box {
      flex: 1;
      height: 100vh;
      border: none;
    }

    .controls {
      width: 350px;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: #f9f9f9;
      display: flex;
      flex-direction: column;
      gap: 15px;
      color: #000;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    label {
      width: 20px;
    }

    input[type="range"] {
      flex-grow: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 3px;
      background: transparent;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: none;
      background: currentColor;
      cursor: pointer;
      margin-top: -4px;
      position: relative;
      z-index: 2;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: none;
      background: currentColor;
      cursor: pointer;
      position: relative;
      z-index: 2;
    }

    input[type="range"]::-moz-range-track {
      background: transparent;
      height: 6px;
    }

    input[type="range"].red {
      color: red;
    }

    input[type="range"].green {
      color: green;
    }

    input[type="range"].blue {
      color: blue;
    }

    input[type="number"],
    input[type="text"] {
      font-size: 1rem;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    input[type="number"] {
      width: 50px;
    }

    input[type="text"] {
      width: 150px;
      text-transform: lowercase;
    }

    select {
      font-size: 1rem;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid transparent;
      cursor: pointer;
      user-select: none;
    }

    p {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 0;
      font-weight: normal;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background-color: #121212;
        color: #f0f0f0;
      }

      .controls {
        background-color: #1e1e1e;
        color: #f0f0f0;
      }

      input,
      select {
        background-color: #2a2a2a;
        color: #f0f0f0;
        border-color: transparent;
      }

      /* ensure the select's displayed text (and SVG icon via currentColor) uses the same color */
      select#colorFormat {
        color: #f0f0f0;
      }

      input[type="text"]::placeholder {
        color: #aaa;
      }
    }

    input#colorInput {
      background: transparent;
      border: none;
      /* remove any border */
      outline: none;
      /* remove outline when not focused / normally */
      box-shadow: none;
      /* remove any shadow that might look like border */
      width: 100px;
      min-width: 100px;
      max-width: 100%;
      /* don't let flexbox shrink the measured width */
      flex: 0 0 auto;
      display: inline-block;
      font-family: Arial, sans-serif;
      font-size: 1rem;
      box-sizing: content-box;
      text-transform: lowercase;
    }

    input#colorInput:focus {
      border: none;
      outline: none;
      box-shadow: none;
    }

    /* Wrap the select so we can use an inline SVG that reliably inherits currentColor */
    .select-wrap {
      position: relative;
      display: inline-block;
      vertical-align: middle;
      color: inherit;
      /* inherit color from parent so SVG follows theme */
    }

    select#colorFormat {
      -webkit-appearance: none;
      appearance: none;
      background-color: transparent;
      border: none;
      padding-right: 1.4em;
      /* room for the SVG icon placed absolutely */
      position: relative;
      cursor: pointer;
    }

    /* Inline SVG positioned over the select; uses currentColor via stroke="currentColor" */
    .select-wrap svg {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      width: 1em;
      height: 1em;
      pointer-events: none;
      /* allow clicks to reach the select */
      color: inherit;
      /* inherit from surrounding text color */
      stroke: currentColor;
      fill: none;
    }

    /* Ensure the path stroke follows currentColor in all browsers */
    .select-wrap svg path {
      stroke: currentColor !important;
    }

    /* Accessible focus style for keyboard users */
    select#colorFormat:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.18);
      border-radius: 4px;
    }

    #widthCalc {
      position: absolute;
      top: -9999px;
      left: -9999px;
      visibility: hidden;
      white-space: pre;
      font-family: Arial, sans-serif;
      font-size: 1rem;
      font-weight: normal;
      text-transform: lowercase;
      padding: 4px;
      border: none;
      box-sizing: content-box;
    }
  </style>
</head>

<body>
  <div class="titlebar"></div>
  <div class="color-box" id="colorBox" aria-live="polite" aria-label="Color preview box"></div>
  <div class="controls" role="region" aria-label="Color controls">
    <div class="slider-container">
      <label for="red">R</label>
      <input type="range" id="red" class="red" min="0" max="255" value="255" aria-label="Red value slider" />
      <input type="number" id="redNumber" min="0" max="255" value="255" aria-label="Red value input" />
    </div>
    <div class="slider-container">
      <label for="green">G</label>
      <input type="range" id="green" class="green" min="0" max="255" value="0" aria-label="Green value slider" />
      <input type="number" id="greenNumber" min="0" max="255" value="0" aria-label="Green value input" />
    </div>
    <div class="slider-container">
      <label for="blue">B</label>
      <input type="range" id="blue" class="blue" min="0" max="255" value="0" aria-label="Blue value slider" />
      <input type="number" id="blueNumber" min="0" max="255" value="0" aria-label="Blue value input" />
    </div>
    <p>
      <span class="select-wrap">
        <select id="colorFormat" aria-label="Select color format">
          <option value="hex" selected>HEX</option>
          <option value="hsl">HSL</option>
          <option value="cmyk">CMYK</option>
          <option value="lch">LCH</option>
          <option value="lab">LAB</option>
        </select>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" aria-hidden="true" focusable="false">
          <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="48"
            d="M112 184l144 144 144-144" />
        </svg>
      </span>
      <input type="text" id="colorInput" maxlength="20" value="#ff0000" aria-label="Color value input"
        spellcheck="false" />
    <div id="widthCalc"></div>

    </p>
  </div>

  <script>
    function setRGBandUpdate(r, g, b) {
      sliderElements.red.value = r;
      sliderElements.green.value = g;
      sliderElements.blue.value = b;
      updateColorDisplay(r, g, b);
    }

    const sliders = ["red", "green", "blue"];
    const sliderElements = {};
    const numberInputs = {};
    const valueDisplays = {
      colorInput: document.getElementById("colorInput"),
      colorBox: document.getElementById("colorBox"),
      formatSelect: document.getElementById("colorFormat"),
    };

    sliders.forEach((color) => {
      sliderElements[color] = document.getElementById(color);
      numberInputs[color] = document.getElementById(color + "Number");
    });

    function updateSliderFill(slider) {
      const val = Number(slider.value);
      const min = Number(slider.min);
      const max = Number(slider.max);
      const percent = ((val - min) / (max - min)) * 100;

      let color;
      if (slider.id === "red") color = "255, 0, 0";
      else if (slider.id === "green") color = "0, 128, 0";
      else if (slider.id === "blue") color = "0, 0, 255";

      const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      const trackColor = isDark ? "#444" : "#ccc";

      slider.style.background = `linear-gradient(to right, rgb(${color}) ${percent}%, ${trackColor} ${percent}%)`;
    }

    function componentToHex(c) {
      const hex = c.toString(16);
      return hex.length == 1 ? "0" + hex : hex;
    }

    function rgbToHex(r, g, b) {
      return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
    }

    function hexToRgb(hex) {
      hex = hex.replace(/^#/, "");
      if (hex.length === 3) hex = hex.split("").map((ch) => ch + ch).join("");
      if (hex.length !== 6) return null;
      const bigint = parseInt(hex, 16);
      if (isNaN(bigint)) return null;
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return { r, g, b };
    }

    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
    }

    function rgbToCmyk(r, g, b) {
      if (r === 0 && g === 0 && b === 0) return { c: 0, m: 0, y: 0, k: 100 };
      let c = 1 - r / 255;
      let m = 1 - g / 255;
      let y = 1 - b / 255;
      let k = Math.min(c, m, y);
      c = ((c - k) / (1 - k)) * 100;
      m = ((m - k) / (1 - k)) * 100;
      y = ((y - k) / (1 - k)) * 100;
      k *= 100;
      return { c: Math.round(c), m: Math.round(m), y: Math.round(y), k: Math.round(k) };
    }

    function rgbCompand(c) {
      return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    }
    function rgbUncompand(c) {
      return c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
    }
    function labFn(t) {
      return t > 0.008856 ? Math.pow(t, 1 / 3) : (7.787 * t) + (16 / 116);
    }
    function labInvFn(t) {
      const t3 = Math.pow(t, 3);
      return t3 > 0.008856 ? t3 : (t - 16 / 116) / 7.787;
    }

    function rgbToLch(r, g, b) {
      r = rgbCompand(r / 255); g = rgbCompand(g / 255); b = rgbCompand(b / 255);
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      const X = x / 0.95047, Y = y / 1.0, Z = z / 1.08883;
      const fx = labFn(X), fy = labFn(Y), fz = labFn(Z);
      const L = 116 * fy - 16;
      const a = 500 * (fx - fy);
      const b_ = 200 * (fy - fz);
      const C = Math.sqrt(a * a + b_ * b_);
      let H = Math.atan2(b_, a) * (180 / Math.PI);
      if (H < 0) H += 360;
      return { l: +L.toFixed(2), c: +C.toFixed(2), h: +H.toFixed(2) };
    }

    function lchToRgb(L, C, H) {
      const hRad = H * Math.PI / 180;
      const a = C * Math.cos(hRad);
      const b_ = C * Math.sin(hRad);
      const fy = (L + 16) / 116;
      const fx = fy + a / 500;
      const fz = fy - b_ / 200;
      const X = labInvFn(fx) * 0.95047;
      const Y = labInvFn(fy) * 1.0;
      const Z = labInvFn(fz) * 1.08883;
      let r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      let g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      let b = X * 0.0557 + Y * -0.2040 + Z * 1.0570;
      r = rgbUncompand(r); g = rgbUncompand(g); b = rgbUncompand(b);
      return {
        r: Math.max(0, Math.min(255, Math.round(r * 255))),
        g: Math.max(0, Math.min(255, Math.round(g * 255))),
        b: Math.max(0, Math.min(255, Math.round(b * 255)))
      };
    }

    function rgbToLab(r, g, b) {
      r = rgbCompand(r / 255);
      g = rgbCompand(g / 255);
      b = rgbCompand(b / 255);

      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

      const X = x / 0.95047, Y = y / 1.0, Z = z / 1.08883;
      const fx = labFn(X), fy = labFn(Y), fz = labFn(Z);

      const L = 116 * fy - 16;
      const a = 500 * (fx - fy);
      const b_ = 200 * (fy - fz);

      return { l: +L.toFixed(2), a: +a.toFixed(2), b: +b_.toFixed(2) };
    }

    function labToRgb(L, a, b_) {
      const fy = (L + 16) / 116;
      const fx = fy + a / 500;
      const fz = fy - b_ / 200;

      const X = labInvFn(fx) * 0.95047;
      const Y = labInvFn(fy) * 1.0;
      const Z = labInvFn(fz) * 1.08883;

      let r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      let g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      let b = X * 0.0557 + Y * -0.2040 + Z * 1.0570;

      r = rgbUncompand(r);
      g = rgbUncompand(g);
      b = rgbUncompand(b);

      return {
        r: Math.max(0, Math.min(255, Math.round(r * 255))),
        g: Math.max(0, Math.min(255, Math.round(g * 255))),
        b: Math.max(0, Math.min(255, Math.round(b * 255)))
      };
    }

    function updateColorDisplay(r, g, b) {
      sliders.forEach(color => updateSliderFill(sliderElements[color]));
      if (Number(numberInputs.red.value) !== r) numberInputs.red.value = r;
      if (Number(numberInputs.green.value) !== g) numberInputs.green.value = g;
      if (Number(numberInputs.blue.value) !== b) numberInputs.blue.value = b;
      valueDisplays.colorBox.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
      const format = valueDisplays.formatSelect.value;
      if (format === "hex") {
        valueDisplays.colorInput.value = rgbToHex(r, g, b);
        // Ensure width recalculation runs after the value change and any layout
        // caused by it has settled. Use the scheduler to avoid intermittent
        // failures when switching formats like LAB.
        scheduleUpdateWidth();
      } else if (format === "hsl") {
        const hsl = rgbToHsl(r, g, b);
        valueDisplays.colorInput.value = `${hsl.h}, ${hsl.s}%, ${hsl.l}`;
        scheduleUpdateWidth();
      } else if (format === "cmyk") {
        const cmyk = rgbToCmyk(r, g, b);
        valueDisplays.colorInput.value = `${cmyk.c}%, ${cmyk.m}%, ${cmyk.y}%, ${cmyk.k}%`;
        scheduleUpdateWidth();
      } else if (format === "lch") {
        const lch = rgbToLch(r, g, b);
        valueDisplays.colorInput.value = `${lch.l}%, ${lch.c}, ${lch.h}`;
        scheduleUpdateWidth();
      } else if (format === "lab") {
        const lab = rgbToLab(r, g, b);
        valueDisplays.colorInput.value = `${lab.l}, ${lab.a}, ${lab.b}`;
        scheduleUpdateWidth();
      }
    }

    function syncFromSliders() {
      const r = Number(sliderElements.red.value);
      const g = Number(sliderElements.green.value);
      const b = Number(sliderElements.blue.value);
      updateColorDisplay(r, g, b);
    }

    const input = document.getElementById('colorInput');
    const calc = document.getElementById('widthCalc');

    function updateWidth() {
      const style = window.getComputedStyle(input);
      calc.style.font = style.font;
      calc.style.fontSize = style.fontSize;
      calc.style.fontWeight = style.fontWeight;
      calc.style.letterSpacing = style.letterSpacing;
      calc.style.textTransform = style.textTransform;
      calc.style.fontFamily = style.fontFamily;
      calc.style.padding = style.padding;

      let val = input.value || input.placeholder || "";
      val = val.replace(/ /g, '\u00a0'); // preserve spaces
      calc.textContent = val;

      const newWidth = calc.offsetWidth + 2; // 2px buffer
      const minWidth = 100;

      // Compute available width inside the parent (.controls -> <p>) so the
      // input expands up to the space left by the select element.
      const parent = input.parentElement; // the <p> flex container
      const parentStyle = window.getComputedStyle(parent);
      const parentPaddingLeft = parseFloat(parentStyle.paddingLeft) || 0;
      const parentPaddingRight = parseFloat(parentStyle.paddingRight) || 0;
      const parentWidth = parent.clientWidth - parentPaddingLeft - parentPaddingRight;

      const selectEl = document.getElementById('colorFormat');
      const selectWidth = selectEl ? selectEl.offsetWidth : 0;
      const gap = parseFloat(parentStyle.gap) || 10;

      // Leave a small buffer for spacing
      const maxWidth = Math.max(50, parentWidth - selectWidth - gap - 8);

      let adjustedWidth = Math.max(minWidth, newWidth);

      // Snap to 10px increments so resizing is less janky
      adjustedWidth = Math.ceil(adjustedWidth / 10) * 10;

      if (adjustedWidth > maxWidth) adjustedWidth = maxWidth;

      input.style.width = adjustedWidth + 'px';
    }



    input.addEventListener('input', updateWidth);
    input.addEventListener('paste', () => setTimeout(scheduleUpdateWidth, 0));

    // Schedule width updates via requestAnimationFrame to ensure measurements
    // occur after any layout changes (for example when the select's value
    // changes and the browser needs to reflow). This prevents intermittent
    // failures to expand the input when switching formats like LAB.
    let widthRaf = null;
    function scheduleUpdateWidth() {
      if (widthRaf) cancelAnimationFrame(widthRaf);
      widthRaf = requestAnimationFrame(() => {
        widthRaf = null;
        updateWidth();
      });
    }

    // Use the scheduler for input events that may coincide with layout
    // changes. Kept lightweight so frequent edits still feel snappy.
    input.addEventListener('input', scheduleUpdateWidth);

    scheduleUpdateWidth(); // call on load

    // Right-click (contextmenu) on the color input: copy current displayed value
    // and show a temporary feedback message for 1.5s. Left-click should allow
    // editing (focus + select). While the feedback is visible we prevent editing.
    (function () {
      let copiedTimer = null;
      let isShowing = false;
      let isProcessing = false;
      let originalValue = null;
      let prevTextTransform = '';
      const copiedMessage = 'Copied!';

      async function copyText(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text);
        }
        // Fallback for older browsers
        return new Promise((resolve, reject) => {
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          try {
            const ok = document.execCommand('copy');
            document.body.removeChild(ta);
            ok ? resolve() : reject(new Error('execCommand failed'));
          } catch (err) {
            document.body.removeChild(ta);
            reject(err);
          }
        });
      }

      function restoreCopiedState() {
        if (copiedTimer) {
          clearTimeout(copiedTimer);
          copiedTimer = null;
        }
        if (isShowing) {
          input.value = originalValue || '';
          input.readOnly = false;
          input.style.textTransform = prevTextTransform || '';
          scheduleUpdateWidth();
          isShowing = false;
        }
        isProcessing = false;
        originalValue = null;
        prevTextTransform = '';
      }

      // Left-click (button 0) should enable editing: focus and select existing text
      input.addEventListener('mousedown', (ev) => {
        if (ev.button === 0) {
          // If the 'Copied!' feedback is currently showing, prevent left-click
          // from enabling editing or focusing the input until we restore state.
          if (isShowing) {
            ev.preventDefault();
            input.readOnly = true;
            // Ensure the input doesn't gain focus (defensive)
            setTimeout(() => input.blur(), 0);
            return;
          }

          input.readOnly = false;
          // Let the default focus behavior run, but ensure the text is selected
          // after the event loop so it doesn't conflict with browser selection.
          setTimeout(() => {
            input.focus();
            input.select();
          }, 0);
        }
      });

      input.addEventListener('contextmenu', async (ev) => {
        ev.preventDefault();

        // If a copy is currently in-flight (but not yet showing feedback), ignore
        if (isProcessing && !isShowing) return;

        const current = input.value;

        // If feedback is already showing, restart the timeout and re-copy the value
        if (isShowing) {
          // attempt to copy again (best-effort)
          try {
            await copyText(originalValue || current);
          } catch (err) {
            console.warn('Copy failed', err);
          }
          if (copiedTimer) clearTimeout(copiedTimer);
          copiedTimer = setTimeout(() => {
            restoreCopiedState();
          }, 1500);
          return;
        }

        // Start a new copy/show cycle
        isProcessing = true;
        originalValue = current;
        input.readOnly = true;
        input.blur();

        try {
          await copyText(originalValue);
        } catch (err) {
          // ignore copy errors but still show UI feedback
          console.warn('Copy failed', err);
        }

        // Show feedback (consistent casing). Temporarily override the CSS
        // text-transform so the capital 'C' is visible, then restore it.
        prevTextTransform = input.style.textTransform || '';
        input.style.textTransform = 'none';
  input.value = copiedMessage;
  scheduleUpdateWidth();
        isShowing = true;

        // Restore after 1.5s
        copiedTimer = setTimeout(() => {
          restoreCopiedState();
        }, 1500);
      });

      // If the user switches format while the copied message is showing,
      // immediately restore the original value and cancel the timer.
      if (valueDisplays && valueDisplays.formatSelect) {
        valueDisplays.formatSelect.addEventListener('change', () => {
          restoreCopiedState();
        });
      }
    })();


    function syncFromNumbers() {
      const r = Number(numberInputs.red.value);
      const g = Number(numberInputs.green.value);
      const b = Number(numberInputs.blue.value);
      sliderElements.red.value = r;
      sliderElements.green.value = g;
      sliderElements.blue.value = b;
      updateColorDisplay(r, g, b);
    }

    function syncFromTextInput() {
      let val = valueDisplays.colorInput.value.trim().toLowerCase();
      const format = valueDisplays.formatSelect.value;
      if (format === "hex") {
        if (!val.startsWith("#")) val = "#" + val;
        const rgb = hexToRgb(val);
        if (rgb) setRGBandUpdate(rgb.r, rgb.g, rgb.b);
      } else if (format === "hsl") {
        const match = val.match(/(\d+),\s*(\d+)%?,\s*(\d+)%?/);
        if (match) {
          const h = +match[1], s = +match[2] / 100, l = +match[3] / 100;
          const rgb = hslToRgb(h, s, l);
          setRGBandUpdate(rgb.r, rgb.g, rgb.b);
        }
      } else if (format === "cmyk") {
        const match = val.match(/(\d+)%?,\s*(\d+)%?,\s*(\d+)%?,\s*(\d+)%?/);
        if (match) {
          const c = +match[1] / 100, m = +match[2] / 100, y = +match[3] / 100, k = +match[4] / 100;
          const rgb = cmykToRgb(c, m, y, k);
          setRGBandUpdate(rgb.r, rgb.g, rgb.b);
        }
      } else if (format === "lch") {
        const match = val.match(/([\d.]+)%?,\s*([\d.]+),\s*([\d.]+)/);
        if (match) {
          const l = +match[1], c = +match[2], h = +match[3];
          const rgb = lchToRgb(l, c, h);
          setRGBandUpdate(rgb.r, rgb.g, rgb.b);
        }
      }
    }

    function hslToRgb(h, s, l) {
      h /= 360;
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        }
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
    }

    function cmykToRgb(c, m, y, k) {
      const r = 255 * (1 - c) * (1 - k);
      const g = 255 * (1 - m) * (1 - k);
      const b = 255 * (1 - y) * (1 - k);
      return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
    }

    // === Event Listeners ===
    sliders.forEach(color => {
      sliderElements[color].addEventListener("input", () => {
        numberInputs[color].value = sliderElements[color].value;
        syncFromSliders();
      });
      numberInputs[color].addEventListener("input", () => {
        let val = Number(numberInputs[color].value);
        val = isNaN(val) ? 0 : Math.max(0, Math.min(255, val));
        numberInputs[color].value = val;
        sliderElements[color].value = val;
        syncFromNumbers();
      });
    });

    valueDisplays.formatSelect.addEventListener("change", syncFromSliders);
    valueDisplays.colorInput.addEventListener("change", syncFromTextInput);

    // Initialize display
    syncFromSliders();

    // Keep the input width up-to-date when the window or format changes
    window.addEventListener('resize', updateWidth);
  valueDisplays.formatSelect.addEventListener('change', scheduleUpdateWidth);

    // Respond to dark mode changes
    window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
      sliders.forEach(color => updateSliderFill(sliderElements[color]));
    });

    // EyeDropper (Cmd + P)
    window.addEventListener("keydown", async (e) => {
      if (e.metaKey && (e.key === "P" || e.key === "p")) {
        e.preventDefault();
        if ("EyeDropper" in window) {
          try {
            const eyeDropper = new EyeDropper();
            const result = await eyeDropper.open();
            const rgb = hexToRgb(result.sRGBHex);
            if (rgb) setRGBandUpdate(rgb.r, rgb.g, rgb.b);
          } catch (err) {
            console.error("EyeDropper failed:", err);
          }
        } else {
          alert("Your browser does not support the EyeDropper API.");
        }
      }
    });

    // Also respond to the menu/accelerator triggered from the main process
    if (window.electronAPI && typeof window.electronAPI.onPick === 'function') {
      window.electronAPI.onPick(async () => {
        try {
          if ("EyeDropper" in window) {
            const eyeDropper = new EyeDropper();
            const result = await eyeDropper.open();
            const rgb = hexToRgb(result.sRGBHex);
            if (rgb) setRGBandUpdate(rgb.r, rgb.g, rgb.b);
          } else {
            alert("Your browser does not support the EyeDropper API. Chromium Currently Supports it.");
          }
        } catch (err) {
          console.error('EyeDropper failed or was cancelled', err);
        }
      });
    }

    // Respond to Generate Random Color from main (IPC) if available
    if (window.electronAPI && typeof window.electronAPI.onGenerate === 'function') {
      window.electronAPI.onGenerate(() => {
        try {
          const r = Math.floor(Math.random() * 256);
          const g = Math.floor(Math.random() * 256);
          const b = Math.floor(Math.random() * 256);
          if (typeof setRGBandUpdate === 'function') setRGBandUpdate(r, g, b);
        } catch (err) {
          console.error('Failed to generate random color from IPC:', err);
        }
      });
    }

  </script>
</body>

</html>