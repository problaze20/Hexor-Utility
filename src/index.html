<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hexor Utility</title>
  <style>
  .titlebar {
      height: 28px;
      width: 100%;
      -webkit-app-region: drag;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 999;
      background: rgba(255, 0, 0, 0);
    }
    html, body {
      margin: 0; 
      height: 100%;
      font-family: Arial, sans-serif;
      font-weight: normal;
      color: #000;
      background-color: #fff;
      overflow: hidden;
    }

    body {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    .color-box {
      flex: 1;
      height: 100vh;
      border: none;
    }

    .controls {
      width: 350px;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: #f9f9f9;
      display: flex;
      flex-direction: column;
      gap: 15px;
      color: #000;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    label {
      width: 20px;
    }

    input[type="range"] {
      flex-grow: 1;
    }

    input[type="number"],
    input[type="text"] {
      font-size: 1rem;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    input[type="number"] {
      width: 50px;
    }

    input[type="text"] {
      width: 150px;
      text-transform: lowercase;
    }

    select {
      font-size: 1rem;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #ccc;
      cursor: pointer;
      user-select: none;
    }

    p {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 0;
      font-weight: normal;
    }

    /* Dark Theme */
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #121212;
        color: #f0f0f0;
      }
      .controls {
        background-color: #1e1e1e;
        color: #f0f0f0;
      }
      input, select {
        background-color: #2a2a2a;
        color: #f0f0f0;
        border-color: #555;
      }
      input[type="text"]::placeholder {
        color: #aaa;
      }
    }
  </style>
</head>
<body>
    <div class="titlebar"></div>
  <div class="color-box" id="colorBox" aria-live="polite" aria-label="Color preview box"></div>
  <div class="controls" role="region" aria-label="Color controls">
    <div class="slider-container">
      <label for="red">R</label>
      <input type="range" id="red" min="0" max="255" value="255" aria-label="Red value slider" />
      <input type="number" id="redNumber" min="0" max="255" value="255" aria-label="Red value input" />
    </div>
    <div class="slider-container">
      <label for="green">G</label>
      <input type="range" id="green" min="0" max="255" value="0" aria-label="Green value slider" />
      <input type="number" id="greenNumber" min="0" max="255" value="0" aria-label="Green value input" />
    </div>
    <div class="slider-container">
      <label for="blue">B</label>
      <input type="range" id="blue" min="0" max="255" value="0" aria-label="Blue value slider" />
      <input type="number" id="blueNumber" min="0" max="255" value="0" aria-label="Blue value input" />
    </div>
    <p>
      <select id="colorFormat" aria-label="Select color format">
        <option value="hex" selected>HEX</option>
        <option value="hsl">HSL</option>
        <option value="cmyk">CMYK</option>
      </select>
      <input type="text" id="colorInput" maxlength="20" value="#ff0000" aria-label="Color value input" spellcheck="false" />
      <span id="rgbValue">255, 0, 0</span>
    </p>
  </div>

  <script>
    const sliders = ["red", "green", "blue"];
    const sliderElements = {};
    const numberInputs = {};
    const valueDisplays = {
      rgb: document.getElementById("rgbValue"),
      colorInput: document.getElementById("colorInput"),
      colorBox: document.getElementById("colorBox"),
      formatSelect: document.getElementById("colorFormat"),
    };

    sliders.forEach((color) => {
      sliderElements[color] = document.getElementById(color);
      numberInputs[color] = document.getElementById(color + "Number");
    });

    function componentToHex(c) {
      const hex = c.toString(16);
      return hex.length == 1 ? "0" + hex : hex;
    }

    function rgbToHex(r, g, b) {
      return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
    }

    function hexToRgb(hex) {
      hex = hex.replace(/^#/, "");
      if (hex.length === 3) {
        hex = hex.split("").map((ch) => ch + ch).join("");
      }
      if (hex.length !== 6) return null;

      const bigint = parseInt(hex, 16);
      if (isNaN(bigint)) return null;

      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;

      return { r, g, b };
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b),
        min = Math.min(r, g, b);
      let h, s, l;
      l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }

      return {
        h: Math.round(h * 360),
        s: Math.round(s * 100),
        l: Math.round(l * 100),
      };
    }

    function hslToRgb(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255),
      };
    }

    function rgbToCmyk(r, g, b) {
      if (r === 0 && g === 0 && b === 0) {
        return { c: 0, m: 0, y: 0, k: 100 };
      }
      let c = 1 - r / 255;
      let m = 1 - g / 255;
      let y = 1 - b / 255;

      const minCMY = Math.min(c, m, y);

      c = ((c - minCMY) / (1 - minCMY)) * 100;
      m = ((m - minCMY) / (1 - minCMY)) * 100;
      y = ((y - minCMY) / (1 - minCMY)) * 100;
      const k = minCMY * 100;

      return {
        c: Math.round(c),
        m: Math.round(m),
        y: Math.round(y),
        k: Math.round(k),
      };
    }

    function cmykToRgb(c, m, y, k) {
      c /= 100;
      m /= 100;
      y /= 100;
      k /= 100;
      const r = 255 * (1 - c) * (1 - k);
      const g = 255 * (1 - m) * (1 - k);
      const b = 255 * (1 - y) * (1 - k);
      return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
    }

    function updateUIFromRGB(r, g, b) {
      sliders.forEach((color) => {
        const val = { red: r, green: g, blue: b }[color];
        sliderElements[color].value = val;
        numberInputs[color].value = val;
        sliderElements[color].setAttribute("aria-valuenow", val);
        sliderElements[color].setAttribute(
          "aria-valuetext",
          `${color.charAt(0).toUpperCase() + color.slice(1)}: ${val}`
        );
      });

      valueDisplays.colorBox.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
      valueDisplays.rgb.textContent = `${r}, ${g}, ${b}`;

      const format = valueDisplays.formatSelect.value;
      if (format === "hex") {
        valueDisplays.colorInput.value = rgbToHex(r, g, b);
      } else if (format === "hsl") {
        const hsl = rgbToHsl(r, g, b);
        valueDisplays.colorInput.value = `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
      } else if (format === "cmyk") {
        const cmyk = rgbToCmyk(r, g, b);
        valueDisplays.colorInput.value = `cmyk(${cmyk.c}%, ${cmyk.m}%, ${cmyk.y}%, ${cmyk.k}%)`;
      }
    }

    function parseColorInput(text) {
      text = text.trim().toLowerCase();
      const format = valueDisplays.formatSelect.value;

      if (format === "hex") {
        return hexToRgb(text);
      } else if (format === "hsl") {
        const match = text.match(/hsl\((\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\)/);
        if (match) {
          return hslToRgb(+match[1], +match[2], +match[3]);
        }
      } else if (format === "cmyk") {
        const match = text.match(/cmyk\((\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\)/);
        if (match) {
          return cmykToRgb(+match[1], +match[2], +match[3], +match[4]);
        }
      }

      return null;
    }

    sliders.forEach((color) => {
      sliderElements[color].addEventListener("input", () => {
        const val = Number(sliderElements[color].value);
        numberInputs[color].value = val;
        updateUIFromRGB(
          Number(sliderElements.red.value),
          Number(sliderElements.green.value),
          Number(sliderElements.blue.value)
        );
      });

      numberInputs[color].addEventListener("input", () => {
        let val = Number(numberInputs[color].value);
        if (isNaN(val) || val < 0) val = 0;
        if (val > 255) val = 255;
        numberInputs[color].value = val;
        sliderElements[color].value = val;
        updateUIFromRGB(
          Number(sliderElements.red.value),
          Number(sliderElements.green.value),
          Number(sliderElements.blue.value)
        );
      });
    });

    valueDisplays.formatSelect.addEventListener("change", () => {
      updateUIFromRGB(
        Number(sliderElements.red.value),
        Number(sliderElements.green.value),
        Number(sliderElements.blue.value)
      );
    });

    valueDisplays.colorInput.addEventListener("change", () => {
      const val = valueDisplays.colorInput.value;
      const rgb = parseColorInput(val);
      if (rgb) {
        updateUIFromRGB(rgb.r, rgb.g, rgb.b);
      } else {
        // Reset to current slider values if parsing fails
        updateUIFromRGB(
          Number(sliderElements.red.value),
          Number(sliderElements.green.value),
          Number(sliderElements.blue.value)
        );
      }
    });

    // EyeDropper feature with Shift+P
    window.addEventListener("keydown", async (e) => {
      if (e.shiftKey && (e.key === "P" || e.key === "p")) {
        e.preventDefault();
        if ("EyeDropper" in window) {
          try {
            const eyeDropper = new EyeDropper();
            const result = await eyeDropper.open();
            const rgb = hexToRgb(result.sRGBHex);
            if (rgb) {
              updateUIFromRGB(rgb.r, rgb.g, rgb.b);
            }
          } catch (err) {
            console.error("EyeDropper cancelled or failed:", err);
          }
        } else {
          alert("EyeDropper API not supported in this browser.");
        }
      }
    });

    updateUIFromRGB(255, 0, 0);
  </script>
</body>
</html>
